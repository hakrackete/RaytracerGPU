#version 430 core

layout (local_size_x = 10, local_size_y = 10, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2D imgOutput;

struct HitRecord {
    float parameter;
    vec3 normal;
    vec3 rayDirection;
    vec3 intersectionPoint;
    vec3 color;
};

struct Sphere{
  vec4 position_radius;
  vec4 color_padding;
};

struct Ray{
  vec3 o;
  vec3 d;
};

layout(binding = 1) buffer readonly SphereBuffer {
  Sphere spheres[];
};

layout(binding = 2)buffer readonly myFloats{
  float random_float[];
};

layout (location = 0) uniform float t;



bool sphere_intersect(Ray ray, int myId, out HitRecord hitRecord){
  vec3 sphere_c = spheres[myId].position_radius.xyz;
  float sphere_r = spheres[myId].position_radius.w;
  hitRecord.rayDirection = ray.d;
  vec3 em = ray.o - sphere_c;
  float a = dot(ray.d,ray.d);
  float b = 2 * dot(ray.d,em);
  float c = dot(em,em) - pow(sphere_r,2);

  float disc = pow(b,2) - 4 * a * c;
  if (disc < 0){
    return false;
  }
  float first_root = (-b + sqrt(pow(b,2) - 4 * a * c)) / (2* a);
  float second_root = (-b - sqrt(pow(b,2) - 4 * a * c)) / (2* a);

  float smalles_root = min(first_root,second_root);
  float biggest_root = max(first_root,second_root);
  if (first_root < 0 && second_root < 0){
    return false;
  }
  else if (smalles_root < 0 && biggest_root > 0){
    smalles_root = biggest_root;
  }
  vec3 schnittpunkt = ray.o + smalles_root * ray.d;
  float schnittdistanz = length(schnittpunkt - ray.o);
  if (schnittdistanz > 0 && (hitRecord.parameter == -1 || schnittdistanz < hitRecord.parameter)){
    hitRecord.parameter = schnittdistanz;
    hitRecord.normal = normalize(schnittpunkt - sphere_c);
    hitRecord.intersectionPoint = schnittpunkt;
    hitRecord.color = spheres[myId].color_padding.xyz;
    return true;
  }
  return false;
}

void shade(HitRecord hitRecord, vec3 lightsource, out vec3 color){
  if (hitRecord.parameter == -1){
    float y_axis = float(gl_GlobalInvocationID.y)/imageSize(imgOutput).y;
    color = mix(vec3(1),vec3(0.35,0.4,1.0),y_axis);
    // color = vec3(1);
    return; 
  }
  color = hitRecord.color;
  vec3 N = normalize(hitRecord.normal);
  vec3 L = normalize(lightsource - hitRecord.intersectionPoint);
  vec3 V = normalize(-1 * hitRecord.rayDirection);
  vec3 R = reflect(-L,N);
  vec3 reflectionsvector = 2 * dot(V, N) * N + -1 * V;

  float diffuse_intensity = max((dot(N, L)),0.0);
  float specular_intensity = pow(max(dot(R, V), 0.0), 20.0);
  float ambient_intensity = 1;

  float general_intensity = 0.5 * diffuse_intensity + 0.2 * specular_intensity + 0.3 * ambient_intensity; 
  
  color *= general_intensity;
  // color = hitRecord.color;
  // color = vec3((hitRecord.parameter - 10),0.0,0.0);
  // color = hitRecord.normal;
  // color = R;
}

void intersect(Ray ray,out HitRecord hitRecord){
  for (int id = 0; id < spheres.length(); id++){
    sphere_intersect(ray,id,hitRecord);
  }
}


void main(){
    memoryBarrierBuffer();

    vec4 pixel = vec4(0.0, 0.0, 0.0, 1.0);
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    vec2 jitter = noise2(t);
    vec2 AA_pixel_coords = pixel_coords + jitter;
    ivec2 dims = imageSize(imgOutput);


    float max_x = dims.x / 100.0;
    float max_y = dims.y /100.0;
    vec2 uv = vec2(pixel_coords)/ dims * 2 - vec2(1.0);

    float x = uv.x;
    float y = uv.y;


    
    // vec3 sphere_c = vec3(0.0,0.0,-10.0);
    // float sphere_r = 3.0;


    vec3 lightsource =  vec3(10.0,0.0,0.0);
    HitRecord hitRecord;
    hitRecord.parameter = -1;
    Ray ray;
    ray.o = vec3(x * max_x,y*max_y,0.0);
    ray.d = normalize(vec3(0.0,0.0,-1.0));
    intersect(ray,hitRecord);
    vec3 myColor = vec3(0.0);
    shade(hitRecord,lightsource,myColor);
    // float bufferSize = spheres.length();
    // myColor = vec3(t);
    memoryBarrierBuffer();

    // if (spheres[1].radius ==0){
    //   myColor = vec3(0.5);
    // }

    pixel.xyz = myColor;

    imageStore(imgOutput, pixel_coords, pixel);
    
}